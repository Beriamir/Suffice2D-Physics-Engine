<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Raycast Grid Demo</title>
    <style>
      body {
        background-color: black;
      }
      canvas {
        background: #111;
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="400" height="600"></canvas>
    <script>
      class Vector2 {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        static subtract(a, b) {
          return new Vector2(a.x - b.x, a.y - b.y);
        }

        static normalize(v) {
          const mag = Math.hypot(v.x, v.y) || 1;
          return new Vector2(v.x / mag, v.y / mag);
        }

        static multiply(v, scalar) {
          return new Vector2(v.x * scalar, v.y * scalar);
        }

        static add(a, b) {
          return new Vector2(a.x + b.x, a.y + b.y);
        }
      }

      class AABB {
        constructor(x, y, w, h) {
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;
        }

        overlaps(other) {
          return (
            Math.abs(this.x - other.x) * 2 < this.w + other.w &&
            Math.abs(this.y - other.y) * 2 < this.h + other.h
          );
        }
      }

      class Client {
        constructor(x, y, size = 20) {
          this.position = new Vector2(x, y);
          this.bound = new AABB(x, y, size, size);
          this.size = size;
        }

        draw(ctx, color = '#999') {
          ctx.fillStyle = color;
          ctx.fillRect(
            this.position.x - this.size / 2,
            this.position.y - this.size / 2,
            this.size,
            this.size
          );
        }
      }

      class SpatialGrid {
        constructor(x, y, width, height, scale) {
          this.bound = [x, y, width, height];
          this.columns = Math.floor(width / scale);
          this.rows = Math.floor(height / scale);
          this.grid = Array.from(
            { length: this.columns * this.rows },
            () => []
          );
          this.scale = scale;
        }

        _index(x, y) {
          return y * this.columns + x;
        }

        _clamp(value, min = 0, max = 1) {
          return value < min ? min : value > max ? max : value;
        }

        _range(x, y, width, height) {
          const min = [
            this._clamp(
              Math.floor((x - width) / this.scale),
              0,
              this.columns - 1
            ),
            this._clamp(Math.floor((y - height) / this.scale), 0, this.rows - 1)
          ];
          const max = [
            this._clamp(
              Math.floor((x + width) / this.scale),
              0,
              this.columns - 1
            ),
            this._clamp(Math.floor((y + height) / this.scale), 0, this.rows - 1)
          ];
          return [min, max];
        }

        addData(client) {
          const { w, h } = client.bound;
          const [min, max] = this._range(
            client.position.x,
            client.position.y,
            w * 0.5,
            h * 0.5
          );

          for (let x = min[0]; x <= max[0]; ++x) {
            for (let y = min[1]; y <= max[1]; ++y) {
              const index = this._index(x, y);
              this.grid[index].push(client);
            }
          }
        }

        _cellRaycast(origin, direction, maxDistance = 1000) {
          const scale = this.scale;
          let cx = Math.floor(origin.x / scale);
          let cy = Math.floor(origin.y / scale);
          const stepX = Math.sign(direction.x);
          const stepY = Math.sign(direction.y);

          const tDeltaX = Math.abs(scale / (direction.x || 1e-6));
          const tDeltaY = Math.abs(scale / (direction.y || 1e-6));

          const gridX = cx * scale;
          const gridY = cy * scale;

          let tMaxX =
            direction.x >= 0
              ? (gridX + scale - origin.x) / direction.x
              : (origin.x - gridX) / -direction.x;

          let tMaxY =
            direction.y >= 0
              ? (gridY + scale - origin.y) / direction.y
              : (origin.y - gridY) / -direction.y;

          const results = new Set();
          let distanceTraveled = 0;

          while (
            cx >= 0 &&
            cy >= 0 &&
            cx < this.columns &&
            cy < this.rows &&
            distanceTraveled < maxDistance
          ) {
            const index = this._index(cx, cy);
            const cell = this.grid[index];

            for (let obj of cell) {
              const toPoint = Vector2.multiply(direction, distanceTraveled);
              const rayPos = Vector2.add(origin, toPoint);
              const rayBound = new AABB(rayPos.x, rayPos.y, 1, 1);
              if (rayBound.overlaps(obj.bound)) {
                results.add(obj);
              }
            }

            if (tMaxX < tMaxY) {
              distanceTraveled = tMaxX;
              tMaxX += tDeltaX;
              cx += stepX;
            } else {
              distanceTraveled = tMaxY;
              tMaxY += tDeltaY;
              cy += stepY;
            }
          }

          return Array.from(results);
        }

        render(ctx) {
          const [x0, y0, width, height] = this.bound;

          ctx.fillStyle = '#000000';
          ctx.fillRect(x0, y0, width, height);

          ctx.strokeStyle = '#ffffff47';
          ctx.beginPath();
          for (let x = 0; x <= this.columns; ++x) {
            const gx = x0 + x * this.scale;
            ctx.moveTo(gx, y0);
            ctx.lineTo(gx, y0 + height);
          }
          for (let y = 0; y <= this.rows; ++y) {
            const gy = y0 + y * this.scale;
            ctx.moveTo(x0, gy);
            ctx.lineTo(x0 + width, gy);
          }
          ctx.stroke();

          ctx.fillStyle = '#8708082e';
          for (let i = 0; i < this.grid.length; ++i) {
            if (this.grid[i].length > 0) {
              const x = i % this.columns;
              const y = Math.floor(i / this.columns);

              ctx.fillRect(
                x * this.scale,
                y * this.scale,
                this.scale,
                this.scale
              );
            }
          }
        }
      }

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      const grid = new SpatialGrid(0, 0, canvas.width, canvas.height, 40);
      const clients = [];

      for (let i = 0; i < 100; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const c = new Client(x, y);
        clients.push(c);
        grid.addData(c);
      }

      const origin = new Vector2(canvas.width / 2, canvas.height / 2);
      let mouse = new Vector2(canvas.width / 2, canvas.height / 2);

      canvas.addEventListener('mousemove', e => {
        mouse = new Vector2(e.offsetX, e.offsetY);
      });
      canvas.addEventListener('touchmove', e => {
        mouse = new Vector2(e.touches[0].clientX, e.touches[0].clientY);
      });

      function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        grid.render(ctx);

        const dir = Vector2.subtract(mouse, origin);
        const direction = Vector2.normalize(dir);

        const hits = grid._cellRaycast(origin, direction, 1000);

        for (const c of clients) {
          const hit = hits.includes(c);
          c.draw(ctx, hit ? '#ff5e5e' : '#666');
        }

        ctx.strokeStyle = '#00ffff';
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(mouse.x, mouse.y);
        ctx.stroke();

        requestAnimationFrame(loop);
      }

      loop();
    </script>
  </body>
</html>
